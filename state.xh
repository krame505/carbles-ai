#include <unification.xh>
#include <list.xh>
#include <map.xh>
#include <prolog_utils.xh>
#include <stdlib.h>

#ifndef _STATE_XH
#define _STATE_XH

#define SECTOR_SIZE 18
#define HOME_BACKTRACK_DIST 2

typedef unsigned player;

datatype position {
  Out(unsigned ?);
  Home(player ?, unsigned ?);
};
typedef datatype position position;

static inline int comparePosition(position p1, position p2) {
  return match (p1, p2)
    (Home(_, _), Out(_) -> 1;
     Out(_), Home(_, _) -> -1;
     Home(a, _), Home(b, _) @when (a != b) -> a - b;
     Home(_, i), Home(_, j) -> i - j;
     Out(i), Out(j) -> i - j;);
}

static inline int compareUnsigned(unsigned x, unsigned y) {
  return x - y;
}

datatype state {
  State(unsigned ?numPlayers,
        map<position, player, comparePosition> ?board,
        map<player, unsigned, compareUnsigned> ?lot);
};
typedef datatype state state;

enum card {
  Joker, Ace,
  Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten,
  Jack, King, Queen
};
typedef enum card card;

typedef list<card ?> hand;

datatype move {
  MoveOut(player ?);
  Move(position ?from, position ?to);
  Swap(position ?, position ?);
};
typedef datatype move move;

datatype action {
  Play(card ?, list<move ?> ?);
  Burn(card ?);
};
typedef datatype action action;

prolog {
  move(state ?, move ?, state ?);
  moves(state ?, list<move ?> ?, state ?);
  
  advanceStep(state ?, position ?, position ?);
  retreatStep(state ?, position ?, position ?);
  advance(state ?, position ?, unsigned ?, position ?);
  retreat(state ?, position ?, unsigned ?, position ?);
  seqAdvance(state ?, player ?, unsigned ?, list<move ?> ?);
  
  directCard(card ?);
  moveOutCard(card ?);
  cardMoves(state ?, player ?, card ?, list<move ?> ?);
  handMoves(state ?, player ?, hand ?, list<move ?> ?);
  action(state ?, player ?, hand ?, action ?);
#include "state.pl"
}

#endif
