#include <unification.xh>
#include <list.xh>
#include <map.xh>
#include <prolog_utils.xh>
#include <string.xh>
#include <vector.xh>
#include <stdlib.h>

#ifndef _STATE_XH
#define _STATE_XH

#define SECTOR_SIZE 18
#define NUM_PIECES 4
#define FINISH_BACKTRACK_DIST 2
#define MIN_HAND 4
#define MAX_HAND 5

typedef unsigned PlayerId;

datatype Position {
  Out(unsigned ?);
  Finish(PlayerId ?, unsigned ?);
};
typedef datatype Position Position;

var_reference datatype Position with GC_malloc;

static inline int comparePosition(Position p1, Position p2) {
  return match (p1, p2)
    (Finish(_, _), Out(_) -> 1;
     Out(_), Finish(_, _) -> -1;
     Finish(?&a, _), Finish(?&b, _) @when (a != b) -> a - b;
     Finish(_, ?&i), Finish(_, ?&j) -> i - j;
     Out(?&i), Out(?&j) -> i - j;);
}

static inline int compareUnsigned(unsigned x, unsigned y) {
  return x - y;
}

datatype State {
  St(unsigned ?numPlayers,
     map<Position, PlayerId, comparePosition> ?board,
     map<PlayerId, unsigned, compareUnsigned> ?lot);
};
typedef datatype State State;

enum Card {
  Joker, A,
  J = 11, Q, K,
  CARD_MAX
};
typedef enum Card Card;

datatype Move {
  MoveOut(PlayerId ?);
  MoveDirect(Position ?from, Position ?to);
  Swap(Position ?, Position ?);
};
typedef datatype Move Move;

var_reference datatype Move with GC_malloc;

typedef unsigned Hand[CARD_MAX];

datatype Action {
  Play(Card, list<Move ?> ?);
  Burn(Card);
};
typedef datatype Action Action;

Card getActionCard(Action);

string showPlayerId(PlayerId p);
string showPosition(Position ?p);
string showState(State s);
string showMoveDirect(Move ?m);
string showMoves(list<Move ?> ?m);
string showHand(Hand);
string showAction(Action a);
string showActions(vector<Action> a);

string jsonPosition(Position ?p);
string jsonState(State s);
string jsonHand(Hand);
string jsonActions(vector<Action> a);

PlayerId ?copyPlayerId(PlayerId ?);
Position ?copyPosition(Position ?);
Move ?copyMoveDirect(Move ?);
list<Move ?> ?copyMoves(list<Move ?> ?);

void initializeDeck(Hand);
unsigned getDeckSize(Hand);
unsigned deal(unsigned min, unsigned max, Hand deck, unsigned numPlayers, Hand hands[numPlayers]);

State initialState(unsigned numPlayers);
State applyMoveDirect(Move, State);
State applyMoves(list<Move ?> ?, State);
State applyAction(Action, State, Hand, Hand);

vector<Action> getActions(State s, PlayerId p, Hand h);
_Bool isWon(State s);
PlayerId getWinner(State s);

#endif
