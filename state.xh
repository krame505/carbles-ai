#include <unification.xh>
#include <list.xh>
#include <map.xh>
#include <prolog_utils.xh>
#include <string.xh>
#include <vector.xh>
#include <stdlib.h>

#ifndef _STATE_XH
#define _STATE_XH

#define SECTOR_SIZE 18
#define NUM_PIECES 4
#define FINISH_BACKTRACK_DIST 2

typedef unsigned player;

datatype position {
  Out(unsigned ?);
  Finish(player ?, unsigned ?);
};
typedef datatype position position;

var_reference datatype position with GC_malloc;

static inline int comparePosition(position p1, position p2) {
  return match (p1, p2)
    (Finish(_, _), Out(_) -> 1;
     Out(_), Finish(_, _) -> -1;
     Finish(?&a, _), Finish(?&b, _) @when (a != b) -> a - b;
     Finish(_, ?&i), Finish(_, ?&j) -> i - j;
     Out(?&i), Out(?&j) -> i - j;);
}

static inline int compareUnsigned(unsigned x, unsigned y) {
  return x - y;
}

datatype state {
  State(unsigned ?numPlayers,
        map<position, player, comparePosition> ?board,
        map<player, unsigned, compareUnsigned> ?lot);
};
typedef datatype state state;

enum card {
  Joker, A,
  J = 11, K, Q,
  CARD_MAX
};
typedef enum card card;

datatype move {
  MoveOut(player ?);
  Move(position ?from, position ?to);
  Swap(position ?, position ?);
};
typedef datatype move move;

var_reference datatype move with GC_malloc;

typedef unsigned hand[CARD_MAX];

datatype action {
  Play(card, list<move ?> ?);
  Burn(card);
};
typedef datatype action action;

string showPosition(position ?p);
string showState(state s);
string showMove(move ?m);
string showMoves(list<move ?> ?m);
string showHand(hand);
string showAction(action a);
string showActions(vector<action> a);

player ?copyPlayer(player ?);
position ?copyPosition(position ?);
move ?copyMove(move ?);
list<move ?> ?copyMoves(list<move ?> ?);

state initialState(unsigned numPlayers);
state applyMove(move, state);
state applyMoves(list<move ?> ?, state);
state applyAction(action, hand, hand, state);

vector<action> getActions(state s, player p, hand h);

#endif
